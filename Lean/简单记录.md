/-
Tactic 列表：(它们都需要前置 by 来使用)

这是显然的！
aesop

自动证明, 但注意自动生成的代码里可能把空格搞成了换行, 需要动手改正. 另外, 不要对它抱多少希望, 因为即便是非常显然非常短的证明, 它也可能找不到
apply?
exact?

要证的东西得换个写法
rw?

遇事不决, 化简一下
simp, simp [*], simp [h], simp at p, simp at *

把证明留给读者:
sorry

应用 h 改写目标
apply h

把假设 h 写入目标中
revert h

从语境中拆分, 有 设 什么什么 的意思
intro a

从命题中拆分, 有取出第一个谓词的意思
intros a

插入证明一个小结论
have h : ...

引入新的量, 但其实跟上面的 have 是完全相同的
let a : ...
set a : U := ...
其实还是有点区别。用 let 定义会被各种 tactic 展开，但用 have 定义就不会。

更灵活的 have
obtain ⟨a, p, X⟩ : ... :=

自己动手重写目标, 与 let 联合使用可以实现修改符号的效果
show

代入等式, 把等式左边替换为等式右边. 注意: rw 有时候非常蠢, 不用括号括起来它就不会认
rewrite [h]
rw [h]

代入等式, 但把等式右边替换为左边
rewrite [←h]
rw [←h]

代入等式, 但不是针对默认目标, 而是别的东西
rw [h] at p

拆开 if-else 与 match 以便分类讨论:
split
split at p

拆开联结词以便分类讨论：
by_cases on h with h1, h2

举例证明存在性命题
existsi a, b, ...

类似 exists 但好一点
use

把存在唯一性( ∃! )目标拆分成两部分
exists_unique

不妨设
wlog h : P

展开目标, 引入具体的任意、存在
choose

展开命题 hyp
choose a b h h' using hyp

用反证法, 构造(不应该成立的)假设 h
by_contra' h

矛盾!
contradiction

用数学归纳法
by_induc

尝试线性方法
linarith

当 linarith 不行的时候试试这个交换环方法
ring
ring_nf

比较具体数值
norm_num

尝试用或证连续性
continuity

尝试拆分关系类命题
gcongr

比较复杂的拆分方法
rcases

尝试证明非负或正
positivity

一些正规化策略：
exact_mod_cast, apply_mod_cast, norm_cast, push_cast, rw_mod_cast, assumption_mod_cast

展开定义
unfold

只需证
suffices ... by ...
也可以拆分成两个子目标来写
suffices ...
· by
· by

逆否命题
contrapose!
contrapose! h

把 ¬ 尽量往右推
push_neg at h

当目标被拆分成多个子目标之后，用 · 逐个进入子目标

不知道要写什么名称, 就丢个占位符 _ 让电脑自己看看怎么办

有时候 exact? 找不到证明, 也许是因为复杂的上下文干扰了程序, 这时候另起一个新的 lean 文件把要证的东西放进去, 说不定 exact? 就能找到证明了.
lean 看起来一个文件里写不了多长的代码, 两百行恐怕就接近上限了.

报错的时候, 看看 空格、换行、缩进 的情况, 在这方面改变写法, 也许就能解决问题, 虽然我也不知道 lean4 的语言怎么这么乱七八糟的

variable (G : ???)
那么 def a := F(G) 并不是记录了 F(G) 这个值, 而是定义了跟 F 差不多的映射, 只不过这个映射有个默认自变量 G 而已. 因此, #check a = F(G) 会报错!

使用除法需要声明最后除出来的结果是什么类型, 例如
(a / b : ℕ)
(a / b : ℝ)

当 s : Set A 且 a : s 时, 不能直接写 a ∈ s, 但可以写 (a : A) ∈ s

docs\undergrad.yaml 列举了本科数学的一些内容

证明初等函数的连续性：先 unfold 函数，然后用 continuity

更新仓库之后，要 lake update, 要 lake build

如果没有现成的 tactic 帮忙拆分，也可以自己动手拆，例如：
theorem 定理名 : 定理内容 :=
  ⟨a, p, X⟩ where
    a : ℕ := 0
    p : a ≤ 1 := by ...
    X : ℕ → ℝ := ...

llmstep：
就是个续写工具，你起的开头会被原样保留。
不会读取当前目标的外部信息，因而需要给它提供自足的目标。
每次运行都有随机性，同样的输入会得到不同的输出。
已经能够写比较长的证明了，虽然本质上还是只写了一句。有时候觉得比自带的 apply? 强不少。但它同样会给出很多方向错误的提示。


-/
