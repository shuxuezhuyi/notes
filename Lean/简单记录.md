/-
### Tactic 列表
它们都需要前置 by 来使用，并且文件头需要 import Mathlib.Tactic

这是显然的！
aesop

自动证明, 但注意自动生成的代码里可能把空格搞成了换行, 需要动手改正. 另外, 不要对它抱多少希望, 因为即便是非常显然非常短的证明, 它也可能找不到
apply?

要证的东西得换个写法
rw?

遇事不决, 化简一下
simp, simp [*], simp [h], simp at p, simp at *

把证明留给读者:
sorry

修改局部表达式
conv =>
conv at h =>

应用 h 改写目标
apply h

一些正规化策略：
exact_mod_cast, apply_mod_cast, norm_cast, push_cast, rw_mod_cast, assumption_mod_cast

把假设 h 写入目标中
revert h

从语境中拆分, 有 设 什么什么 的意思
intro a

从命题中拆分, 有取出第一个谓词的意思
intros a

插入证明一个小结论
have h : ...

引入新的量, 但其实跟上面的 have 是完全相同的
let a : ...
set a : U := ...
其实还是有点区别。用 let 定义会被各种 tactic 展开，但用 have 定义就不会。

更灵活的 have
obtain ⟨a, p, X⟩ : ... :=

自己动手重写目标, 与 let 联合使用可以实现修改符号的效果
show
有时候发现目标里过度展开某些定义，也可以用它写回去

代入等式, 把等式左边替换为等式右边. 注意: rw 有时候非常蠢, 不用括号括起来它就不会认
rewrite [h]
rw [h]

代入等式, 但把等式右边替换为左边
rewrite [←h]
rw [←h]

代入等式, 但不是针对默认目标, 而是别的东西
rw [h] at p

拆开 if-else 与 match 以便分类讨论:
split
split at p

根据已知条件 (h : p ∨ q) 做分类讨论：
cases h with
| inl h => ...
| inr h => ...
另有 rcases

举例证明存在性命题
existsi a, b, ...

类似 existsi 但好一点
use

把存在唯一性( ∃! )目标拆分成两部分
exists_unique

不妨设
wlog h : P

展开目标, 引入具体的任意、存在
choose

展开命题 hyp
choose a b h h' using hyp

用反证法, 构造(不应该成立的)假设 h
by_contra' h

矛盾!
contradiction

如果你觉得 h 已经够矛盾了，你可以
revert h; apply?

用数学归纳法
by_induc

尝试线性方法
linarith

当 linarith 不行的时候试试这个交换环方法
ring
ring_nf

比较具体数值
norm_num

尝试用或证连续性
continuity

尝试拆分关系类命题
gcongr

以最原始的方式拆分目标
constructor

尝试证明非负或正
positivity

展开定义
unfold
unfold_let

只需证
suffices ... by ...
也可以拆分成两个子目标来写
suffices ...
· by
· by

逆否命题
contrapose!
contrapose! h

把 ¬ 尽量往右推
push_neg at h

当目标被拆分成多个子目标之后，用 · 逐个进入子目标

不知道要写什么名称, 就丢个占位符 _ 或 ?_ 让电脑自己看看怎么办

自动生成的证明有时候需要把 ↑x 改成 x.val 才行

有时候 exact? 找不到证明, 也许是因为复杂的上下文干扰了程序, 这时候另起一个新的 lean 文件把要证的东西放进去, 说不定 exact? 就能找到证明了.
lean 看起来一个文件里写不了多长的代码, 两百行恐怕就接近上限了.

如果没有现成的 tactic 帮忙拆分，也可以自己动手拆，例如：
theorem 定理名 : 定理内容 :=
  ⟨a, p, X⟩ where
    a : ℕ := 0
    p : a ≤ 1 := by ...
    X : ℕ → ℝ := ...

### 一些重要的函数

从“存在 x 使得……”中取出具体的 x
Classical.subtype_of_exists

连续映射把收敛点列映为收敛点列
Continuous.seqContinuous 吃进连续，返回点列连续

### 一些 apply? 还不能自动提示的命题

距离等于范数
dist_eq_norm

滤子收敛等于ε-δ收敛
Metric.tendsto_nhds  -- 函数极限
Metric.tendsto_atTop  -- 点列极限

在滤子表达式中更换相等的函数
Filter.Tendsto.congr

### 其它

如果电脑性能足够强，那么 import Mathlib 就再也不用关心 import 的问题了

报错的时候, 看看 空格、换行、缩进 的情况, 在这方面改变写法, 也许就能解决问题, 虽然我也不知道 lean4 的语言怎么这么乱七八糟的

variable (G : ???)
那么 def a := F(G) 并不是记录了 F(G) 这个值, 而是定义了跟 F 差不多的映射, 只不过这个映射有个默认自变量 G 而已. 因此, #check a = F(G) 会报错!

使用除法需要声明最后除出来的结果是什么类型, 例如
(a / b : ℕ)
(a / b : ℝ)

当 s : Set A 且 a : s 时, 不能直接写 a ∈ s, 但可以写 (a : A) ∈ s

v 的范数要写成 ‖v‖，不能写成 ‖ v ‖, 否则会报错。另外，要写范数就要引入范数的定义，例如在文件开头 import Mathlib.Analysis.NormedSpace.Basic

docs\undergrad.yaml 列举了本科数学的一些内容

证明初等函数的连续性：先 unfold 函数，然后用 continuity

更新仓库之后，要 lake update, 要 lake build

当证明分成很多层之后，在较深的层里可能无法使用 calc

如果书上的证明写了半页纸以上，那就不要尝试在 Lean 中写成一个证明，你应该把它拆分成几个引理。
稍微复杂一点的证明就要先写自然语言的版本，因为 Lean 给出的语境会变得很难阅读。

用 section 可能会导致内存占用多很多。

llmstep：
就是个续写工具，你起的开头会被原样保留。
不会读取当前目标的外部信息，因而需要给它提供自足的目标。
每次运行都有随机性，同样的输入会得到不同的输出。
已经能够写比较长的证明了，虽然本质上还是只写了一句。有时候觉得比自带的 apply? 强不少。但它同样会给出很多方向错误的提示。


-/
